# Load Balancing Rules Overview

<br>

### Sabse Pehle â€“ Algorithm Ki Zaroorat Hi Kyun?

Load Balancer ka main kaam:
- ğŸ‘‰ Incoming traffic ko backend servers ke beech distribute karna.

Lekin question:
- â“ Kaise distribute kare?
  - Random?
  - Order mein?
  - Fastest server ko?
  - Least busy ko?
 
Isi decision logic ko bolte hain: **Load Balancing Algorithm**.

Matlab Load Balancing Algorithm se hi Load Balancer decide karta hai ki incoming request ko konse backend server pe bhejna hai. 

<br>
<br>

### Load Balancing Algorithms Kitne Type ki Hoti Hain

Load Balancing Algorithms two types ki hoti hain:
- Static Load Balancing Algorithm.
  - Round-Robin Algorithm.
  - Weighted Round-Robin.
  - IP Hash.
- Dynamic Load Balancing Algorithms.
  - Least-Connection Method.
  - Least-Response Time.
  - Weighted Least Connection.
 
<br>
<br>

### Static Load Balancing Algorithms

Static Load Balancing algorithms wo algorithms hote hain jahan traffic distribute karne ka decision pehle se set kiye gaye fixed rules par based hota hai.

Iska matlab hai ki ye algorithms predefined rules ke according backend se vm select karte hain traffic ko distribute karne ke liye.

Ye algorithms "Real-time" data ko nahi dekhte. Matlab, Load Balancer ye check nahi karta ki server kitna busy hai, uski CPU utilization kitni hai, ya wo kitna slow respond kar raha hai. Load Balancer bas apne pehle se bane hue rules ko follow karke backend se vm select karta hai aur traffic us vm par bhejta hai.

In algorithms ke types hain:
- Round-Robin Algorithm.
- Weighted Round-Robin.
- IP Hash.

<br>
<br>

### Round Robin Algorithm

Ye sabse basic aur simple algorithm hai.

Round Robin ka basic idea hai ki incoming requests ko sequential order mein servers ke beech distribute karna â€” ek ek karke, cyclic manner mein.

Iska matlab hai ki round-robin algorithm incoming requests ko ek ke baad ek server pe distribute karti hai cyclic manner mein.

**Example**:

Imagine karo tumhare paas multiple backend servers hain:
- Server A.
- Server B.
- Server C.

Load Balancer kya karega ki:
- 1st request â†’ A.
- 2nd request â†’ B.
- 3rd request â†’ C.
- 4th request â†’ A (cycle repeat).
- 5th request â†’ B.
- 6th request â†’ C.

Aur ye loop chalta rahega.

Ismein koi intelligence nahi hoti jaise:
- âŒ Server load check karna.
- âŒ CPU utilization dekhna.
- âŒ Fast/slow server detect karna.

<br>

**Algorithm Internally Kaise Kaam Karta Hai?**:

Conceptually ek pointer / index counter maintain hota hai.

Example:

Total backends = 3

Index values:
- 0 â†’ Server A.
- 1 â†’ Server B.
- 2 â†’ Server C.

Har request pe:
```
selected_server = backends[current_index]
current_index = (current_index + 1) % total_backends
```

Yahan % (modulo) ensure karta hai ki index rotate kare.

Execution:

| Request | Current Index | Server |
| ------- | ------------- | ------ |
| Req 1   | 0             | A      |
| Req 2   | 1             | B      |
| Req 3   | 2             | C      |
| Req 4   | (3 % 3 = 0)   | A      |

Simple circular rotation.

<br>

**Round-Robin Algorithm kaha best hai**:

Jab aapke saare backend servers ki configuration (RAM, CPU, Storage) bilkul identical (ek jaisi) ho tab ye algorithm sahi hoti hai.

<br>

**Problem kaha aati hai**:

Problem tab hoti hai jab servers unequal hon matlab kisi server ki configuration high aur kisi ki low.

Example:
- Server A â†’ Powerful (16 CPU cores).
- Server B â†’ Weak (2 CPU cores).

To is case mein round robin algorithm Server B (Weak Server) pe fir bhi traffic ko bhejta jayega jisse Server B overload ho sakta hai aur down ho jayega.

Result:
- Server A: Underutilized.
- Server B: Overload.

<br>
<br>

### Weighted Round Robin

Weighted Round-Robin algorithm Round-Robin algorithm ka updated version hai ya smart version hai.

Weighted Round Robin (WRR) ko samajhne ke liye pehle ek simple sawal:
- Agar saare servers equal capacity ke nahi hain, to kya unko equal traffic dena logical hai?

Bilkul nahi.

Isi problem ko solve karta hai Weighted Round Robin.

Weighted Round Robin algorithm mein servers ko unki configuration ke hisab se ek weight matlab ek number assign kar dete hain, fir jitna jyada server ka weight hoga us server pe utna jyada traffic bheja jata hai.

Har server ko weight (priority / capacity value) assign hoti hai.

Higher weight â‡’ More requests

**Example**:

Suppose load balancer ke backend mein 3 servers hain:
- Server A (8 CPU & 32 GB RAM).
- Server B (4 CPU & 16 GB RAM).
- Server C (2 CPU & 8 GB RAM).

To in servers ko inki capacity ya configuration ke hisaab se ek weight assign kar denge.

- Server A (8 CPU & 32 GB RAM) = **6**.
- Server B (4 CPU & 16 GB RAM) = **3**.
- Server C (2 CPU & 8 GB RAM) = **2**.

Execution:

- Request 1 = Server A.
- Request 2 = Server A.
- Request 3 = Server A.
- Request 4 = Server B.
- Request 5 = Server B.
- Request 6 = Server c.

Repeat

- Request 7 = Server A.
- Request 8 = Server A.

Ese hi servers request distribute hoti hain.

Notice:
- A gets 3/6 traffic = 50%.
- B gets 2/6 traffic = 33%.
- C gets 1/6 traffic = 17%.

<br>

**Practical Server Example**:

Backend pool:
- Server A â†’ 8 CPU cores â†’ Weight 4.
- Server B â†’ 4 CPU cores â†’ Weight 2.
- Server C â†’ 2 CPU cores â†’ Weight 1.

Total weight = 7

Traffic pattern per 7 requests:
- A, A, A, A, B, B, C

<br>

**Weighted Round-Robin Algorithm Kaha Best Hai**:

Jab aapke cluster mein purane aur naye servers mix hon. Naye servers ko zyada weight de kar aap unhe zyada kaam de sakte hain.


<br>
<br>

### IP Hash Algorithm

IP Hash algorithm mein client ke IP address se ek hash value banti hai, aur us hash ke basis par decide hota hai kaunsa backend server request handle karega.

Iska matlab:
- Same Client IP.
- Same Hash.
- Same backend server (jab tak backend healthy hai).

Is algorithm mein Client ke IP address ke basis pe backend server select kiya jata hai.

**Example**:

Socho tumhare paas 3 backend servers hain:
- Server A.
- Server B.
- Server C.

Total backends = 3

Step 1ï¸âƒ£: Client Request Aata Hai

Client IP
```
192.168.1.10
```

Step 2ï¸âƒ£: Hash Function Apply Hota Hai
```
hash("192.168.1.10") = 84523   (example)
```

Step 3ï¸âƒ£: Modulo Operation
```
84523 % 3 = 2
```
3 = Total Servers

Step 4ï¸âƒ£: Backend Selection

Index mapping:
- 0 â†’ Server A.
- 1 â†’ Server B.
- 2 â†’ Server C.

Request goes to Server C


Same Client Dubara Aaya?

Same IP â‡’ Same hash â‡’ Same modulo â‡’ Same server

- Session consistency.
- Predictable routing.

**Kyu Use Karte hain**:

Agar aapne kisi website par login kiya hai aur aapka session data Server A par store hai, toh IP Hash ensure karega ki aapki har agli request Server A par hi jaye. Agar aap Server B par chale gaye, toh aap log-out ho jayenge kyunki Server B ke paas aapka session nahi hai.

<br>
<br>
<br>

### Dynamic Load Balancing Algorithm

Dynamic Load Balancing Algorithm real time mein backend server ki **real-time health**, **current traffic**, aur **performance** ko har second monitor karte hain aur phir decide karte hain ki request konse backend server pe bhejni hai.

Agar ek server par zyada load hai ya wo slow ho gaya hai, toh dynamic load balancer usse bypass karke kisi free server ko traffic bhej dega.

Ye algorithm real-time mein decision leti hain ki konse backend server par request bhejni hai.

In algorithm ke types hain:
- Least-Connection Method.
- Least-Response Time.
- Weighted Least Connection.

<br>
<br>

### Least-Connection Method:

Least-Connection Method algorithm ka basic idea hai ki jis backend server ke paas sabse kam active connections hain, nayi request usko bhejo.

Yahan decision request order pe nahi hota (Round Robin jaisa), aur na hi client identity pe (IP Hash jaisa).

Decision purely based on:
- Current server load (connection count).

Example:
- Agar Server A par 50 log hain aur Server B par sirf 10, toh naya user Server B ke paas jayega.

<br>

**Algorithm Ka Core Logic**:

Isme har backend server ke liye Load Balancer maintain karta hai:
- Active connection counter.

Example:
| Server | Active Connections |
| ------ | ------------------ |
| A      | 10                 |
| B      | 3                  |
| C      | 7                  |

New request â†’ Server B

Kyuki Server B pe sabse kam request hain.

<br>

**Internally Kaise Kaam Karta Hai?**:

Load Balancer continuously track karta hai:
- Kitne TCP connections open hain.
- Kab connection close hua.
- Real-time counters update.

<br>

**Example Scenario (Important)**:

Servers:
- A â†’ Processing time = 5 sec.
- B â†’ Processing time = 1 sec.

Traffic high.

Result:
- Server A â†’ Connections pile up.
- Server B â†’ Quickly free.

Least Connections:
- More new requests â†’ Server B.

<br>

**But Connection Count Always Accurate Load Metric Hai?**:

Not always.

Edge case:

Server A:
- 2 connections.
- But extremely CPU-heavy jobs.

Server B:
- 10 lightweight connections.

Least Connections Algorithm yaha â†’ A choose karega (wrong decision).

Isliye Weighted-Least Connection algorithm use hota hai.

<br>
<br>

### Least-Response Time:

Least-Response Time algorithm ka basic idea ye hai ki Jo backend server sabse fast response de raha hai, next request usko bhejo.

Matlab jo backend server sabse fast hai to next request usko behjo.

Example:
| Server | Avg Response Time |
| ------ | ----------------- |
| A      | 120 ms            |
| B      | 35 ms             |
| C      | 80 ms             |

New request â†’ Server B.

Because B fastest.

<br>

**Load Balancer Response Time Kaise Measure Karta Hai?**:

Load balancer continuously track karta:
- Request bhejne ka time.
- Response receive ka time.
- Difference = Latency.

Formula:
```
Response Time = Response_Received_Time - Request_Sent_Time
```

Phir moving averages maintain hoti hain.

<br>

**Moving Average kya hota hai?**

Moving average ka matlab hai ki pichle 10 ya 50 request ka average response time kya tha.

Seedhe shabdon mein: Load balancer sirf server ke pichle ek (last) response time ko nahi dekhta, balki pichli kuch requests (jaise last 10 ya 50 requests) ka ek average nikaalta hai. Isse "fluctuations" ya achanak aane wale spikes se bacha ja sakta hai.

Example:

Maan lijiye ek server ne ek request 10ms mein process ki, lekin agli request mein ek heavy database query ki wajah se usse 500ms lag gaye.
- Agar load balancer sirf last response dekhega, toh wo us server ko "slow" maan kar traffic rok dega.
- Lekin agar wo Moving Average dekhega, toh use pata chalega ki overall server abhi bhi fast hai, bas ek request slow thi.

<br>

**Why Moving Average Use Karte?**:

Single request misleading ho sakta.

Example:

Server A:
- Normally fast.
- Ek request slow due to GC pause.

Agar sirf last response dekhenge â†’ Wrong decision.

Isliye moving average dekhte hain.

<br>

**Weaknesses / Edge Cases**:

âŒ Cold Start Problem

Server just started:
- No history.
- No response metrics.

Decision unstable ho sakta.

Solution:
- Warm-up logic / default routing.

<br>
<br>

### Weighted-Least Connection Algorithm

Weighte Least connection algorithm mein pehle server ka weight yani capacity check ki jaati hai fir server par active connection check kiye jate hain, agar jis server ki capacity jyada hai aur saath hi agar us server pa active connection kam hain us server ko request bheji jaati hai.

<br>

**Sabse Pehle Problem Samjho**:

Tumhare paas 3 servers hain:
- Server A â†’ Bahut powerful.
- Server B â†’ Medium.
- Server C â†’ Weak.

Agar hum sirf Least Connections use karein:
- To Jiske paas sabse kam connections â†’ Usko request jayegi.

But issue:

Weak server ko bhi powerful server ke barabar treat kar diya.

Ye unfair hai.

Isliye:
- Connections ko directly compare mat karo. Pehle server ki capacity dekho. Jis server par kam connections ho aur saath hi uska weight jyada ho usko request bhejo.

Formula:
```
Score = Active Connections / Weight
```

Lowest score = Best server.

<br>

**Weight Ka Matlab Kya Hai?**:

Weight = Server ki à¤¤à¤¾à¤•à¤¤ (capacity)

Example:
- Server A â†’ Weight 5 (strong).
- Server B â†’ Weight 2 (medium).
- Server C â†’ Weight 1 (small).

Higher weight â‡’ Zyada load handle kar sakta hai.

<br>

**Example With Numbers**:

Current connections:
- Server A â†’ 20 connections.
- Server B â†’ 6 connections.
- Server C â†’ 2 connections.

Agar normal Least Connections:
- To Server C (2 smallest) pe request bhejega.

But WLC kya karega?

Step 1: Score Calculate Karo

Server A:
```
20 / 5 = 4
```

Server B:
```
6 / 2 = 3
```

Server C:
```
2 / 1 = 2
```

Step 2: Lowest Score Dekho:

Scores:
- A â†’ 4.
- B â†’ 3.
- C â†’ 2 âœ….

Next request â†’ Server C.

Ye Logic Kyun Sahi Hai?
- Server A powerful hai â†’ 20 connections normal ho sakta.
- Server C weak hai â†’ 2 bhi heavy ho sakta.

Formula actually bol raha:

ğŸ‘‰ â€œLoad ko capacity ke hisaab se compare karoâ€.

<br>
<br>
<br>

## Azure Load Balancer Konsi Algorithm use karta hai?

Azure Load Balancer 5-tuple hash algorithm use karta hai.

<br>

**Ye 5-Tuple Kya Hai?**:

Azure incoming packet se 5 values leta:
- Source IP address.
- Source Port.
- Destination IP address.
- Destination Port.
- Protocol (TCP/UDP).

In sabko combine karke ek hash number generate hota.

Hash number se backend se VM select karta hai aur uspe request forward kar deta hai.

<br>

**Simplified Internal Working**:
- Client packet Load Balancer pe aaya.
- Azure LB ne 5-tuple read kiya.
- Hash function run hua.
- Hash â†’ Backend VM index mapping.
- Request forwarded to that VM.

Same flow â‡’ Same hash â‡’ Same VM.

<br>

**Example**:

Backend Pool:
- VM1.
- VM2.
- VM3.

Client packet details:
```
SrcIP: 10.0.0.5
SrcPort: 53001
DstIP: 20.30.40.10
DstPort: 443
Protocol: TCP
```

Hash(5-tuple) â†’ say index = VM2.

Ab:
- Entire TCP connection â†’ VM2.

Agar Same Client Dubara Connect Kare?

Agar source port same:
- Same VM likely.

Agar port different:
- Different VM possible.

<br>

**Health Probes Ka Role (CRITICAL)**:

Azure LB blindly hash mapping nahi karta.

Sabse pehle check karta hai ki healthy vm konsa hai. Fir hash mapping karke vm select karta hai.

```
All Backends
â†“
Health Probe Pass
â†“
Healthy Backends Only
â†“
Hash Mapping
```

Unhealthy VM = Removed from selection.

<br>

### 5-Tuple hash ka basic idea

Load balancer packet ke 5 fields uthata hai â†’ Unko math function (hash) mein daalta hai â†’ Ek number milta hai â†’ Us number se backend VM select hota hai.

<br>

**Ye â€œ5 Tuplesâ€ Exactly Kya Hote?**:

Har incoming network packet mein ye values hoti:
- Source IP Address â†’ Client ka IP.
- Source Port â†’ Client ka temporary port.
- Destination IP Address â†’ Load balancer / service IP.
- Destination Port â†’ Jaise 80 / 443.
- Protocol â†’ TCP ya UDP.

Example Network:
```
Source IP        = 10.1.1.5
Source Port      = 54000
Destination IP   = 20.30.40.50
Destination Port = 443
Protocol         = TCP
```

**Step-by-Step Working**:

Assume backend pool:
- VM1.
- VM2.
- VM3.

Total backends = 3

**Step 1 â€“ Packet Arrives**:

Client se packet LB pe aaya.

LB ne read kiya:
```
10.1.1.5 : 54000 â†’ 20.30.40.50 : 443 (TCP)
```

**Step 2 â€“ Combine Values**:

Internally LB kuch aisa conceptually karta:
```
hash_input = "10.1.1.5-54000-20.30.40.50-443-TCP"
```

Real implementation binary level pe hoti, but conceptually ye string socho.

**Step 3 â€“ Hash Function Run**:

Hash function ek deterministic math formula hota.

Output example:
```
hash_value = 847362
```

Important:
- Same input â‡’ Same output.
- Tiny change â‡’ Completely different output.

**Step 4 â€“ Backend Selection (Modulo Trick)**:

Backend count = 3

Formula:
```
847362 % 3 = 0
```

Mapping:
- 0 â†’ VM1.
- 1 â†’ VM2.
- 2 â†’ VM3.

Packet goes to VM1.

<br>

Same Connection Mein Kya Hoga?

Same flow ke next packets:
- Same 5-tuple values â‡’ Same hash â‡’ Same VM.

Result:
- Entire TCP connection pinned to one VM.
- No packet jumping.
- Session stability.

<br>

**Source Port Itna Important Kyun Hai?**:

Ye bahut critical insight hai.

Client jab connect karta:
- Har connection â†’ New ephemeral port (Temporary Port).

Example:

Connection 1:
```
10.1.1.5 : 54000
```

Connection 2:
```
10.1.1.5 : 54001
```

Sirf port change â‡’ Hash change â‡’ Possibly different VM.

<br>

**Health Probe Interaction (Very Important)**:

Before modulo selection:
- Only healthy VMs considered.

If VM2 unhealthy:

Backends effectively:
- VM1.
- VM3.

Modulo now based on 2 servers.

Hash mapping automatically shift.
